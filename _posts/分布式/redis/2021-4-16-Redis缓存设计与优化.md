---
title: Redis缓存设计与优化
date: 2021-4-13 15:52:07 +0800
categories: [分布式, Redis]
tags: [分布式, Redis, 缓存设计]
math: true
image: 
---

### 缓存穿透

查询一个根本不存在的数据，缓存层和存储层都没有这个数据，通常情况下，存储层查不到数据不会放入缓存层。

缓存穿透会造成每次请求不存在的数据都需要到存储层查询，起不到缓存层保护存储层的作用。

#### 原因

1. 自身业务代码或者数据有问题；
2. 恶意攻击造成大量空命中。

#### 解决

##### 缓存空值，并给空值的key设置一个过期时间。

##### 布隆过滤器

对于恶意攻击，向服务器请求大量不存在的数据造成缓存穿透，可以先使用布隆过滤器过滤一次，过滤掉不存在的数据，不让请求往后端发送。当布隆过滤器说一个key存在时，这个key可能不存在；当说这个key不存在时，key一定不存在。

布隆过滤器就是**一个大型的位数组和几个不一样的无偏 hash 函数**。所谓无偏就是能够把元素的 hash 值算得 比较均匀。 

向布隆过滤器中添加 key 时，会使用多个 hash 函数对 key 进行 hash 算得一个整数索引值然后对位数组长度 进行取模运算得到一个位置，每个 hash 函数都会算得一个不同的位置。再把位数组的这几个位置都置为 1 就 完成了 add 操作。 

向布隆过滤器询问 key 是否存在时，跟 add 一样，也会把 hash 的几个位置都算出来，看看位数组中这几个位 置是否都为 1，只要有一个位为 0，那么说明布隆过滤器中这个key 不存在。如果都是 1，这并不能说明这个 key 就一定存在，只是极有可能存在，因为这些位被置为 1 可能是因为其它的 key 存在所致。

适用于数据命中不高，数据相对固定，实时性低，数据集较大的场景，这种方法占用缓存空间较小，但代码维护复杂。

> 需要将使用布隆过滤器的数据提前放入布隆过滤器，有新增数据时，也需要放入布隆过滤器。
>
> 布隆过滤器不能删除数据，需要删除数据时，需要重新初始化数据。
>
> 当位数组越稀疏，计算key是否存在的准确率越高，位数组越拥挤，准确率越低。

### 缓存失效（击穿）

当大批量的缓存数据在同一时间失效导致大量请求同时穿透缓存层到达数据库，可能会造成数据库瞬间压力过大甚至直接挂掉。

#### 场景

电商秒杀，将商品在指定时间上架，一般都会将商品放在缓存中，并设定相同的过期时间，当这批商品缓存同时失效时，大量请求就会击穿缓存直接打到数据库。

#### 解决

设置key缓存过期时间时，设定一个时间范围内的随机时间。

### 缓存雪崩







### 热点缓存key重建优化



### Redis过期键三种清除策略

#### 被动删除

当读写一个已经过期的key时，会触发惰性删除策略，直接删除这个过期的key。

#### 主动删除

由于惰性删除策略无法及时删除冷数据，所以Redis会定期主动淘汰一些**过期**的key。

#### 内存超过maxmemory，主动删除

当Redis使用内存超过maxmemory配置时，会触发**主动删除策略**。

#### 主动删除策略(maxmemory-policy)

主动删除策略在Redis4.0之前有6种，Redis4.0之后新增了volatile-lfu，allkeys-lfu，总共8种：

##### 设置了过期时间的key

1. volatile-ttl

   对设置了过期时间的key，根据过期时间的先后顺序进行删除，越早过期的key越先被删除。

2. volatile-lru

   使用LRU算法筛选设置了过期时间的key进行删除。

3. volatile-lfu

   使用LFU算法筛选设置了过期时间的key进行删除。

4. volatile-random

   在设置了过期时间的key中随机选择进行删除。

##### 所有的key

5. allkeys-lru

   使用LRU算法筛选所有的key进行删除。

6. allkeys-lfu

   使用LFU算法筛选所有的key进行删除。

7. allkeys-random

   在所有的key中随机选择进行删除。

##### 不处理

8. noeviction（默认策略）

   不进行任何处理，只响应读操作，拒绝写操作并返回客户端错误信息“(error) OOM command not allowed when used memory ”。

### LRU与LFU算法

#### LRU（Least Recently Used）

以最近一次访问时间为参考，淘汰很久没被访问过的数据。

比如一个key的最近访问时间为10s之前，另一个key的最近访问时间为1min之前，那么在LRU算法中，会淘汰1min之前那个被访问的key。

#### LFU（Least Frequently Used）

以次数为参考，淘汰最近一段时间被访问次数最少的数据。

#### 选取策略

当存在热点数据时，一些key在一段时间经常被访问，使用LFU更适合。虽然LRU的效率很好，但是偶发性、周期性的批量操作会导致LRU命中率急剧下降，缓存污染情况比较严重。

比如key1在1分钟之前被访问了100次，key2在被访问了两次，一次是10s之前，一次是8小时之前（系统跑批、定时任务之类的程序），那么应该淘汰key2，此时使用LFU算法比较合适。

一般情况推荐使用Volatile-LRU。