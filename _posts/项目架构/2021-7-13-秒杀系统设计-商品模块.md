## 商品模块-秒杀

### 商品业务

- 商品流程图

  商品资料 > 图片处理 > 商品发布 > 商品维护 > 商品下架

- 后台 发布、修改、下架

- 前台 展示、搜索、购买



## 技术难点

### 表的设计

是设计一张表还是多张表？设计的依据是什么？需要判断商品详情页显示的信息它们之间的关系。通过他们的关系，才能知道到底是一张表还是多张表。

- 一张表

  不方便维护，设计复杂，方便查询。

- 多张表

  业务清晰，维护更加方便，但是查询非常复杂，一个商品页面需要查很多的表和数据。

#### 分析



#### 商品分类

这个商品是吃的还是穿的还是用的？需要商品分类。

但是如果需要查看某一个品牌的所有商品，此时就不能满足。

#### 商品品牌





#### 输入属性

同一品牌同一个类型，需要通过不同的属性，可以更快的定位到用户想要的产品。比如手机有：内存、颜色等属性。衣服有：颜色、尺寸等属性。



#### 规格

比如一部手机，是32G内存还是64G内存？内存就是规格，内存值32G就是规格值。不同的规格，商品价格也不同。



### 商品搜索





### 商品展示

商品详情页里面的数据关乎太多的表，如果只用数据库存储这些数据并查询出来，那效率太低，页面看起来也很会卡。可以做一下优化：

- 静态化处理

  将那些经常访问的、又不需要动态变化的静态文件放在CDN中，减少网络磁盘IO，从而加快网页的访问速度。

  FreeMarker是一款模板引擎，可以基于模板和数据源生成文本（HTML网页、配置文件、电子邮件、源码）的通用工具。可以用于非WEB环境中。编写使用FTL（FreeMarker Template Language）。模板中专注于如何展示数据，模板之外可以专注要什么数据。

  利用FreeMarker将商品网页静态化成静态网页，将静态网页放到CDN中。

  但这种方式适合小数量商品架构，会存在以下问题：

  - 问题

    - 不能展示需要实时变化的数据

    - 但需要静态化的网页数据量非常大时，维护这些静态化网页太困难。比如当一个模板修改了，所有应用这些模板产生的静态网页都需要重新生成。

    - 数据同步问题

      当生成一个静态页面时，需要将这个页面同步到其他不同国家、不同地区的CDN中。

      - 同步方式

        - 通过网络同步

          SCP命令，但这种方式太耗费网络，而且当静态网页总量很大时，同步所需的时间也很长。

        - 定时任务

        - 消息中间件

- 多级缓存

  商品详细页的访问方式有一个特点，那就是读多写少。将查询到的商品信息放到Redis中，从而减少对数据库的访问。

  - 全量、增量数据如何同步，从DB到缓存

    - 最终一致性
      - 设置缓存失效时间
    - 
    - 实时一致性

  - 高并发问题

    在并发很大时，当数据还未从DB查询并保存到缓存中时，其他并发还是走的数据库。

    解决：分布式锁

    方式一：

    ~~~java
    public Data getData(Long id){
        Data data = getDataFromCache(id);
        if(null != data){
            return data;
        }
        //获取分布式锁
        Lock lock = getLock(id);
        try{
            //上锁成功
            if(lock.tryLock()){
                data = getDataFromDB(id);
                setDataToCache(data);
            } else{
                //加锁失败，休眠5s，重新
                Thread.sleep(50);
                getData(id);
            }
        }finally{
            //是否还在加锁状态
            if(lock.isLocked()){
                //锁是否被当前线程持有
                if(lock.isHeldByCurrentThread()){
                    //解锁
                    lock.unlock();
                }
            }
        }
        return data;
    }
    ~~~

    方式二：

    ~~~java
    ...
    lock.lock();
    Data data = getDataFromCache(id);
    if(null != data){
        return data;
    }
    lock.unlock();
    ~~~

    

  - 压缩数据问题

    大量的未经压缩的数据保存到Redis中，在查询的时候会存在网络IO问题。

  - 本地缓存

    减少网络IO。

    - ConCurrentHashMap

      需要自定义缓存淘汰策略，容量控制等。

    - gava缓存

      可以自定义缓存容量、缓存过期时间、过期策略expireAfterWrite()、expireAfterAccess()

      

- 

- 特点
  - 热点少
  - 各种爬虫、比价软件抓取



### 大流量商品详情页缓存架构

Lua+Nginx缓存 + 本地JVM缓存 + Redis分布式缓存 三层缓存结构

数据热点：

数据量大小：Redis分布式缓存 > 本地JVM缓存 > Lua+Nginx缓存

热点数据高低：Lua+Nginx缓存 > 本地JVM缓存 > Redis分布式缓存

#### Lua+Nginx第一层

缓存非常热点的数据，内存很小5%左右，比如双十一618活动页商品数据

#### 本地JVM缓存

缓存比较热门的数据，5%-8%商品总量，比如首页这些比较热门的数据

#### Redis缓存

10-15%商品总量，一般商品

根据二八法则，最热的数据占总数据的20%，可以使用LRU算法制定缓存淘汰策略。



>LRU 算法（Least Recently Used，最近最少使用）淘汰很久没被访问过的数据，以最近一次访问时间作为参考。

