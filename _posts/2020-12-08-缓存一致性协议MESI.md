---
title: 缓存一致性协议MESI
date: 2020-12-8 16:56:12 +0800
categories: [并发编程, java]
tags: [并发编程, 缓存, cpu]
math: true
image: 
---

## cpu内存交互图

![cpu内存交互图](/assets/img/study/cpu-memory.png)

cpu会监控bus总线所有对Lock汇编指令修饰（volatile）的变量的存取事件，从而修改变量在缓存中的状态。

当core0读取主内存中的一个变量Lock变量x时，经过bus总线，core1会监听到变量x的读取事件，此时变量x只在core0缓存中存在副本，core0中的x副本会被标记为“E”（独占）状态，此时x副本的值可以被直接修改。

当core1也读取了变量x，core0会监听到，此时变量x有多个变量副本，core1中的x副本会被标记为“S”（分享）状态，core0中的x副本状态会更改“S”分享状态，此时要修改x副本的值，需要先获取变量x所在的缓存行的锁。

当core1锁定x所在的缓存行，会发出总线写信号，core0监听到总线写信号，core0变量x副本状态E->S->I，变为失效，core1变量x副本状态S->E->M。

如果core0和core1都要对x变量副本加锁，那么他们都需要发出总线写信号通知对方，由总线裁决谁加锁成功。

变量x在L3缓存中会有多个缓存行，因为L3缓存是由多核共享的，各个内核处理各自的缓存行。

## MESI

MESI是缓存一致性协议的一种实现方式，MESI描述了一个变量在缓存中的四种状态：

* M：已修改
* E：独占
* S：分享
* I：已失效

### MESI状态切换图

![MESI状态转换](/assets/img/study/MESI-state.jpg)



## **CPU切换状态阻塞解决-存储缓存（Store Bufferes）**

比如你需要修改本地缓存中的一条信息，那么你必须将I（无效）状态通知到其他拥有该缓存数据的CPU缓存中，并且等待确认。等待确认的过程会阻塞处理器，这会降低处理器的性能。应为这个等待远远比一个指令的执行时间长的多。

### **Store Bufferes**

​	


